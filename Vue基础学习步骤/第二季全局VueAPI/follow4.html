<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdn.jsdelivr.net/npm/vue"></script>
    <title>跟4-life</title>
</head>

<body>
    <div id="app">{{msg}}
        <p>{{count}}</p>
        <button @click='add'>加</button>
        <button onclick="app.$destroy()">销毁</button>
    </div>
    <script>
        var app = new Vue({
            el: '#app',
            data: {
                msg: '构造器的生命周期',
                count: 0
            },
            methods: {
                add: function() {
                    this.count++
                }
            },
            beforeCreate: function() {
                console.log('===beforeCreate：在实例初始化之后，数据观测和event/watcher时间配置之前被调用')
            },
            created: function() {
                console.log('===created：实例已经创建完成之后被调用。在这一步，实例已经完成以下的配置，数据观测，属性和方法的运算，watch/event事件回调。然而，挂载阶段还没开始，$el属性目前不可见')
            },
            beforeMount: function() {
                console.log('===beforeMount：在挂载之前被调用：相关的render函数首次被调用。该钩子在服务器渲染期间不被调用。')
            },
            mounted: function() {
                console.log('===mounted：el被创建的vm.$el替换，并挂载到实例上去之后调用该钩子函数。如果root实例挂载了一个文档内元素，当mounted被调用时vm.$el也在文档内。该钩子在服务端渲染期间不被调用。')
            },
            beforeUpdate: function() {
                console.log('===beforeUpdate：数据更新时调用，发生在虚拟DOM重新渲染和补丁之前。你可以在这个钩子中进一步更改状态，这不会触发附加的重新渲染过程。该钩子在服务端渲染期间不被调用。')
            },
            updated: function() {
                console.log('===updated：由于数据更改导致的虚拟DOM重新渲染和补丁，在这之后会调用该钩子。当这个钩子被调用时，组件DOM已经更新，所以你现在可以执行依赖于DOM的操作。然而在大多数情况下，你应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务端渲染期间不被调用')
            },
            activated: function() {
                console.log('===activated：keep-alive组件激活时调用。该钩子在服务端渲染期间不被调用。')
            },
            deactivated: function() {
                console.log('===deactivated：keep-alive组件停用时调用。该钩子在服务端渲染期间不被调用。')
            },
            beforeDestroy: function() {
                console.log('===beforeDestroy：类似于React生命周期的componentWillUnmount。实例销毁之前调用。在这一步，实例仍然完全可用。该钩子在服务端渲染期间不被调用。')
            },
            destroyed: function() {
                console.log('===destroyed：Vue实例销毁后调用。调用后，Vue实例指示的所有东西会解除绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务端渲染期间不被调用。')
            },
        })
    </script>
</body>

</html>